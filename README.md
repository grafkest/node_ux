# Концепция приложения для визуализации модулей и доменных областей

## Запуск прототипа

В репозитории лежит интерактивный прототип на React с визуализацией графа, фильтрами и аналитикой. Ниже — пошаговый алгоритм, как собрать и протестировать проект с помощью Visual Studio Code.

### Настройка окружения

1. Установите [Node.js 18+](https://nodejs.org/en/download). Пакет включает менеджер пакетов `npm`, который используется во всех последующих шагах.
2. Установите [Visual Studio Code](https://code.visualstudio.com/) и запустите его.
3. Через стартовый экран VS Code выберите **Clone Git Repository…**, вставьте URL проекта и дождитесь окончания клонирования. Альтернативно можно открыть уже склонированную папку через **File → Open Folder…**.

### Сборка и запуск через VS Code

1. Откройте интегрированный терминал (горячая клавиша `Ctrl`+`` ` `` или меню **Terminal → New Terminal**). Терминал автоматически окажется в корне проекта. Убедитесь, что в строке состояния и в промпте терминала указан путь к каталогу, где лежит `package.json` (например, `…/domain-graph/`). Если сомневаетесь, выполните `dir` (Windows) или `ls` (macOS/Linux) и убедитесь, что в списке файлов есть `package.json` и `package-lock.json`.
2. Установите зависимости:

   ```bash
   npm install
   ```

3. Запустите сервис постоянного хранения графа в отдельном терминале:

   ```bash
   npm run server
   ```

   Сервер стартует на `http://localhost:4000` и создаст файл базы данных `data/graph.db`. При необходимости измените порт через переменную окружения `PORT` перед запуском. После старта процесс занимает терминал: чтобы выполнить другие команды, откройте новую вкладку/окно терминала или остановите сервер сочетанием `Ctrl`+`C`.

4. Для локального тестирования интерфейса выполните команду разработки (в другом терминале):

   ```bash
   npm run dev
   ```

   VS Code покажет URL в терминале (по умолчанию `http://localhost:5173`). Зажмите `Ctrl` и кликните по ссылке, чтобы открыть приложение в браузере.

   > Если нет возможности открыть второй терминал, используйте объединённую команду:
   >
   > ```bash
   > npm run dev:full
   > ```
   >
   > Она параллельно запустит сервер данных и Vite в одном окне. Для остановки нажмите `Ctrl`+`C` один раз — оба процесса завершатся автоматически.

5. Чтобы собрать production-версию, используйте меню **Terminal → Run Task…**, выберите задачу `npm: build` или запустите команду вручную:

   ```bash
   npm run build
   ```

   Готовые статические файлы появятся в каталоге `dist/`.

6. Для проверки собранной версии локально выполните:

   ```bash
   npm run preview
   ```

   Команда стартует встроенный сервер Vite и выведет ссылку на предварительный просмотр.

### Работа через API Gateway

- Для запуска всех сервисов одной командой используйте Docker Compose: `docker compose up --build gateway auth graph initiatives workforce postgres pgbackups`. Каждая служба применяет миграции на старте и ждёт готовности Postgres через healthchecks, так что порядок запуска контролируется автоматически.
- Gateway слушает порт `4000` и проксирует API (`/api/login`, `/api/users`, `/api/graphs`, `/api/initiatives`, `/api/employees`, `/api/assignments`) на внутренние сервисы. Проверить доступность можно запросом `http://localhost:4000/health`. Для карточки инициативы добавлен агрегирующий маршрут `GET /api/initiatives/:id`, который параллельно собирает данные из Initiatives, Graph и Workforce.
- Чтобы фронтенд ходил в API через Gateway, перед запуском `npm run dev` или `npm run preview` задайте переменную окружения `VITE_GATEWAY_PROXY_TARGET=http://localhost:4000`. После этого все запросы `/api/*` будут направляться через `http://localhost:4000`.

7. По желанию запустите линтер перед коммитом:

   ```bash
   npm run lint
   ```

> Если терминал VS Code сообщает об отсутствии `npm`, убедитесь, что Node.js установлен и VS Code запущен после установки (перезапуск обновит переменные окружения).

### Частые ошибки

- **`npm ERR! enoent ENOENT: no such file or directory, open '…\package.json'`.** Команда выполнена не из корня проекта. Откройте в терминале каталог, где лежит файл `package.json`. Если вы распаковали архив, убедитесь, что зашли во вложенную папку `domain-graph` (иногда архивы добавляют дополнительный уровень вложенности, например `domain-graph-main\domain-graph`).
- **`npm` не является внутренней или внешней командой.** Node.js не установлен или VS Code был открыт до установки. Установите Node.js и перезапустите VS Code.
- **`gyp ERR!` при установке зависимостей (Python/Visual Studio).** Текущая версия хранилища использует `sql.js` и не требует нативной сборки. Обновите репозиторий и повторно выполните `npm install`.
- **`[vite] http proxy error: /api/graphs/... (ECONNREFUSED)`** — интерфейс не может связаться с сервером графа. Откройте второй терминал и выполните `npm run server`, либо запустите обе службы одной командой `npm run dev:full`.


## Постоянное хранение графа

- **Сервер на Express + SQLite (sql.js, без нативной сборки).** В репозитории появился сервис `npm run server`, который предоставляет REST API `/api/graph` для чтения и записи полного снапшота графа. Данные сохраняются в файл `data/graph.db`, а структура включает таблицы доменов, модулей и артефактов с порядковыми позициями.
- **Загрузка при старте.** Клиентское приложение запрашивает текущее состояние из базы и отображает индикатор статуса синхронизации. При недоступности сервера используются встроенные данные, но изменения не отправляются.
- **Автосохранение изменений.** После создания модулей, доменов или артефактов фронтенд отправляет обновлённый снапшот на сервер. Экспорт/импорт по-прежнему доступен для ручных бэкапов.
- **Фиксация раскладки.** Перемещения узлов графа теперь сохраняются и загружаются из базы, поэтому после перезагрузки экрана визуальная раскладка остаётся прежней.


## Цель
В нефтегазовой компании десятки команд создают различные IT-продукты. Из-за отсутствия общей картины модули нередко дублируют друг друга. Цель веб-приложения — визуализировать модули и доменные области в виде графа, чтобы участники могли находить пересечения, избегать повторной разработки и переиспользовать существующие решения.

## Методология и роли

### Общие принципы
- **Граф знаний на основе онтологии.** Знание представляется как сеть сущностей и отношений, что позволяет находить скрытые связи и выполнять сложные запросы.
- **Стратегический и тактический DDD.** Ограниченные контексты определяют границы предметных областей, а тактический уровень задаёт сущности, агрегаты и сервисы.
- **Централизованное хранилище знаний.** Единая база документации и данных обеспечивает самостоятельный доступ к информации и снижает риск повторной разработки.
- **Итеративное развитие.** Онтология и граф пополняются и уточняются по мере появления новых знаний.

### Роли
| Роль | Ответственность |
| --- | --- |
| **Доменный эксперт** | Формирует структуру доменного дерева, валидирует связи между модулями и доменами. |
| **Аналитик / инженер по знаниям** | Собирает требования, проектирует онтологию, определяет атрибуты и поддерживает модели. |
| **Архитектор** | Определяет границы контекстов, стандарты интеграции и согласованность моделей. |
| **Разработчик / владелец модуля** | Описывает модуль, поддерживает актуальность данных. |
| **Ответственный за качество данных** | Организует ревизии, контролирует модульность и переиспользуемость. |

## Процесс наполнения
1. **Анализ домена.** Определение ключевых субдоменов и потенциальных интеграций.
2. **Формирование доменного дерева.** Построение иерархии областей с помощью онтологических инструментов.
3. **Описание модулей.** Добавление узлов типа «Модуль» с атрибутами и связями с доменами.
4. **Связывание модулей.** Моделирование зависимостей между компонентами.
5. **Ревизия и обновление.** Регулярное уточнение данных и связей.
6. **Обучение и обмен знаниями.** Мероприятия по поддержанию качества данных и распространению знаний.
7. **Использование базы.** Фильтрация и изучение модулей по выбранным доменам через веб-интерфейс.

## Уровни декомпозиции доменных областей
1. **Домен / ограниченный контекст.** Крупные предметные области с собственным языком и моделями (например, добыча, транспортировка, экономика).
2. **Поддомен / объект или процесс.** Ключевые сущности или процессы внутри контекста (скважина, бурение, мониторинг).
3. **Функция / модуль.** Конкретные программные компоненты, связанные с объектами и процессами через отношения «использует», «производит» или «зависит».

## Атрибуты сущностей

### Модуль
- Идентификатор
- Название
- Описание
- Доменные области
- Команда / владелец
- Репозиторий исходного кода
- API / интерфейсы
- Зависимости
- Статус
- Показатели
- Переиспользуемость

### Доменный объект или процесс
- Название
- Тип
- Родитель
- Описание
- Синонимы
- Владелец

### Отношения
- **Использует** — модуль использует доменный объект или другой модуль.
- **Производит** — модуль создаёт данные для доменного объекта.
- **Зависит** — модуль зависит от другого модуля.
- **Связан с** — произвольные дополнительные связи.

## Архитектурные компоненты
- **Хранилище графа.** RDF-триплстор (GraphDB, Stardog) или property-graph база (Neo4j) для хранения данных и выполнения запросов.
- **Слой бизнес-логики.** API для чтения и записи графа, валидация данных, правила доступа, поддержка REST/GraphQL/SPARQL.
- **Модуль импорта данных.** ETL/ELT-инструменты для загрузки описаний систем, автоматического извлечения сущностей и связей.
- **Веб-приложение.** Интерфейс на React с использованием Consta UI и Consta Charts, визуализация графа через Reagraph или альтернативы (Cytoscape.js, React Flow).

## Основные функции веб-приложения
1. Навигация по дереву доменов.
2. Поиск и фильтры по командам, статусам и типам связей.
3. Интерактивная карта графа с различными типами узлов и настройками визуализации.
4. Карточка узла с деталями и возможностью редактирования.
5. Формы добавления и изменения сущностей.
6. История изменений и обсуждения.
7. Аналитика и отчёты с использованием диаграмм.
8. Экспорт и импорт данных.

## Пользовательский сценарий
1. Аналитик выбирает доменные области «Скважины» и «Экономика» и видит связанные модули.
2. Обнаруживает дублирующие функции и сравнивает их параметры.
3. Инициирует обсуждение для объединения усилий.
4. После согласования обновляет граф и статусы модулей.

## Практики управления знаниями
- Ведение единой базы знаний и документации.
- Парное программирование и code review.
- Онбординг и наставничество.
- Кросс-командное взаимодействие.
- Регулярные ревизии процессов и данных.

## Технологический стек
- **GraphDB / Stardog** — для семантических моделей и reasoning.
- **Neo4j** — для высокопроизводительных property-графов (при необходимости с neosemantics).
- **Reagraph** или **Cytoscape.js / React Flow** — библиотеки визуализации графов.
- **Consta UI** и **Consta Charts** — дизайн-система и диаграммы.
- **Protégé / Grafo / WebVOWL** — инструменты моделирования онтологий.
- **Elasticsearch** — полнотекстовый поиск поверх графовой базы.

## Развёртывание на продакшн-сервере

### Подготовка к развёртыванию

1. **Соберите production-версию приложения:**

   ```bash
   npm run build
   ```

   Готовые статические файлы появятся в каталоге `dist/`.

2. **Настройте переменные окружения на сервере:**

- `PORT` — порт для backend-сервера (по умолчанию 3003)
- `VITE_API_PROXY_TARGET` — URL backend API (используется только в development/preview режиме Vite)
- `GRAPH_DB_PATH` — путь к файлу БД (по умолчанию `data/graph.db`), можно перенаправить на внешний том/диск

3. **Подготовьте базу данных перед первым запуском:**

   ```bash
   # Создаёт структуру таблиц и файлы БД, если их ещё нет
   GRAPH_DB_PATH=/opt/nedra/data/graph.db npm run init:db
   ```

   Если переменная `GRAPH_DB_PATH` не указана, база создастся в каталоге `data/graph.db` рядом с приложением.

### Вариант 1: Развёртывание с Nginx (рекомендуется)

1. **Скопируйте файлы на сервер:**
   - Каталог `dist/` с собранным фронтендом
   - Каталог `server/` с backend-кодом
   - Файлы `package.json` и `package-lock.json`

2. **Установите зависимости на сервере:**

   ```bash
   npm install --production
   ```

3. **Запустите backend-сервер:**

   ```bash
   # Установите порт через переменную окружения
   PORT=3003 npm run server
   
   # Или используйте PM2 для автозапуска
   pm2 start "npm run server" --name "nedra-expert-api"
   ```

4. **Настройте Nginx как reverse proxy:**

   ```nginx
   server {
       listen 80;
       server_name your-domain.com;
       
       # Статические файлы фронтенда
       location / {
           root /path/to/dist;
           try_files $uri $uri/ /index.html;
       }
       
       # Проксирование API-запросов к backend
       location /api/ {
           proxy_pass http://localhost:3003;
           proxy_http_version 1.1;
           proxy_set_header Upgrade $http_upgrade;
           proxy_set_header Connection 'upgrade';
           proxy_set_header Host $host;
           proxy_cache_bypass $http_upgrade;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       }
   }
   ```

5. **Перезапустите Nginx:**

   ```bash
   sudo nginx -t
   sudo systemctl reload nginx
   ```

### Вариант 2: Развёртывание только с Node.js

Если Nginx недоступен, можно использовать встроенный статический сервер Express:

1. **Добавьте раздачу статики в `server/index.ts`** (после строки `app.use(express.json({ limit: '5mb' }));`):

   ```typescript
   import path from 'node:path';
   
   // Serve static files from dist/
   app.use(express.static(path.join(__dirname, '../dist')));
   
   // Handle client-side routing
   app.get('*', (req, res) => {
     if (!req.path.startsWith('/api/')) {
       res.sendFile(path.join(__dirname, '../dist/index.html'));
     }
   });
   ```

2. **Запустите сервер:**

   ```bash
   PORT=80 npm run server
   ```

### Автозапуск при перезагрузке сервера

Используйте PM2 или systemd для автоматического запуска:

**PM2:**
```bash
pm2 start "npm run server" --name "nedra-expert-api"
pm2 save
pm2 startup
```

**Systemd** (`/etc/systemd/system/nedra-expert.service`):
```ini
[Unit]
Description=Nedra Expert Node API
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/path/to/app
Environment=PORT=3003
ExecStart=/usr/bin/npm run server
Restart=always

[Install]
WantedBy=multi-user.target
```

Затем:
```bash
sudo systemctl enable nedra-expert
sudo systemctl start nedra-expert
```

### Важные замечания

- **База данных:** Перед запуском выполните `npm run init:db` (при необходимости с `GRAPH_DB_PATH`), чтобы создать файл БД и схему. Если файл отсутствует, приложение не увидит хранилище.
- **Права на диск:** Убедитесь, что у процесса есть права на запись в каталог `data/` или путь, заданный `GRAPH_DB_PATH`, особенно при использовании внешних томов/сетевых дисков.
- **HTTPS:** Для production-окружения настоятельно рекомендуется использовать SSL-сертификат (например, через Let's Encrypt с certbot).
- **Безопасность:** В текущей версии аутентификация упрощённая. Для продакшна рекомендуется добавить JWT-токены и более надёжную систему управления сессиями.

## Заключение
Комбинация онтологического моделирования, DDD и современных инструментов визуализации позволяет построить приложение, которое снижает дублирование, ускоряет поиск решений и развивает культуру обмена знаниями в организации.
