# Оптимизация производительности и устранение перерисовок графа

## Проблема
Граф перерисовывается слишком часто, что создает нагрузку на браузер и ухудшает пользовательский опыт. Выявлены две основные проблемы:
1.  **Циклическая перерисовка (каждые ~15 секунд):** Бесконечный цикл обновления позиций между физическим движком и React-стейтом.
2.  **Лишние рендеры при взаимодействии:** Выбор узла вызывает полную перерисовку компонента графа из-за обновления глобального стейта.

## Анализ причин

### 1. Цикл "Симуляция -> Стейт -> Симуляция"
*   `ForceGraph2D` запускает симуляцию.
*   По завершении (`onEngineStop`) новые координаты отправляются в `App.tsx` через `onLayoutChange`.
*   `App.tsx` обновляет стейт `layoutPositions`.
*   Это вызывает рендер `GraphView`, где `useMemo` пересоздает массив `nodes` (так как он зависит от `layoutPositions`).
*   `ForceGraph2D` получает *новые* объекты узлов и перезапускает симуляцию.
*   Цикл повторяется.

### 2. Отсутствие мемоизации
*   `GraphView` не обернут в `React.memo`.
*   Любое обновление в `App.tsx` (даже не связанное с графом, но вызывающее его рендер) приводит к перерисовке `GraphView`.
*   Функции отрисовки (например, `nodeCanvasObject`) создаются заново при каждом рендере, заставляя канвас перерисовываться полностью.

## План решения

### 1. Разрыв цикла обновления позиций
Необходимо перестать передавать обновленные координаты обратно в проп `nodes` для `ForceGraph2D`, если структура графа не изменилась.

*   **Изменить логику `useMemo` для `nodes` в `GraphView.tsx`:**
    *   Массив `nodes` должен пересоздаваться только при изменении *структурных* данных (списки модулей, доменов и т.д.), но **не** при изменении `layoutPositions`.
    *   При инициализации (или изменении структуры) можно подмешивать сохраненные позиции.
    *   Для обновлений позиций "на лету" (если они нужны для других целей) использовать мутации или отдельные механизмы, не затрагивающие проп `graphData` компонента `ForceGraph2D`.

*   **Оптимизировать `onLayoutChange`:**
    *   Проверять, действительно ли изменились координаты значимо (на величину > epsilon), прежде чем вызывать обновление стейта.

### 2. Мемоизация компонентов и пропсов
*   **Обернуть `GraphView` в `React.memo`:**
    *   Настроить функцию сравнения пропсов (custom comparator), если необходимо, чтобы игнорировать изменения функций, которые не влияют на визуализацию.
*   **Стабилизировать колбэки:**
    *   Убедиться, что `nodeCanvasObject`, `linkColor`, `nodeLabel` и другие функции-рендеры обернуты в `useCallback` и не пересоздаются без необходимости.
    *   Вынести функции отрисовки (`drawNode`, `renderCircle` и т.д.) за пределы компонента или в статические утилиты, чтобы ссылки на них были постоянными.

### 3. Оптимизация управления состоянием
*   Использовать `useRef` для хранения текущих позиций узлов внутри `GraphView`, чтобы не вызывать рендер при каждом тике симуляции или драг-н-дропе.
*   Синхронизировать с глобальным стейтом только по завершении взаимодействия (например, `onNodeDragEnd`, `onEngineStop`) и только если изменения существенны.

## Ожидаемый результат
*   Прекращение самопроизвольных перерисовок каждые 15 секунд.
*   Плавное выделение узлов без "мигания" всего графа.
*   Снижение нагрузки на CPU за счет уменьшения количества запусков физической симуляции.
